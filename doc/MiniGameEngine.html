<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MiniGameEngine API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>MiniGameEngine</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import time
import ctypes
import tkinter as tk

try:
    _TIME_BEGIN_PERIOD = ctypes.windll.winmm.timeBeginPeriod
    _TIME_END_PERIOD = ctypes.windll.winmm.timeEndPeriod
except:
    _TIME_BEGIN_PERIOD = lambda n: True
    _TIME_END_PERIOD = lambda n: True


class GameWorld:
    _instance_ = None

    def _getInstance():
        return GameWorld._instance_

    # ---

    def __init__(
        self,
        width: int,
        height: int,
        title: str = &#34;MiniGameEngine&#34;,
        bgColor: str = &#34;gray&#34;,
        bgPath: str = None,
        numLayers: int = 10,
    ):
        &#34;&#34;&#34;
        Constructor de la clase GameWorld que inicializa una instancia del mundo de juego.

        Args:
            width (int): Ancho de la ventana del juego.
            height (int): Altura de la ventana del juego.
            title (str, optional): Título de la ventana del juego (por defecto es &#34;MiniGameEngine&#34;).
            bgColor (str, optional): Color de fondo de la ventana del juego (por defecto es &#34;gray&#34;).
            bgPath (str, optional): Ruta de la imagen de fondo de la ventana del juego (por defecto es None).
            numLayers (int, optional): Numero de capas a permitir en el juego (por defecto es 10).
        &#34;&#34;&#34;
        if not GameWorld._instance_ is None:
            raise Exception(&#34;Ya existe una instancia de GameWorld activa!!!&#34;)

        self.win = tk.Tk()
        self.win.geometry(&#34;%dx%d&#34; % (width, height))
        self.win.title(title)
        self.win.resizable(False, False)

        self.canvas = tk.Canvas(self.win, width=width, height=height, bg=bgColor)
        self.canvas.place(x=0, y=0)

        self.images = {}
        self.bgpic = None
        self.bgpic_obj = self.canvas.create_image(0, 0, anchor=tk.NW)
        self.setBgPic(bgPath)

        self.numLayers = numLayers

        self.keys = {}
        self.tick_prev = 0
        self.fps = 0
        self.gObjects = []
        self.running = False
        GameWorld._instance_ = self

    def _getCanvas(self) -&gt; tk.Canvas:
        return self.canvas

    def loadImage(self, imagePath: str) -&gt; tk.PhotoImage:
        &#34;&#34;&#34;
        Carga la imagen que se encuentra en la ruta especificada

        Args:
            imagePath (str): Ruta de la imagen a cargar.

        Returns:
            binary: La imagen cargada.
        &#34;&#34;&#34;
        if not imagePath in self.images:
            self.images[imagePath] = tk.PhotoImage(file=imagePath)
        return self.images[imagePath]

    def loadImages(self, imagesPaths: list) -&gt; list:
        &#34;&#34;&#34;
        Carga las imagenes referenciadas por el arreglo de rutas

        Args:
            imagesPaths (list): Arreglo de rutas a las imagenes a cargar.

        Returns:
            list : Arreglo con las imágenes cargadas.
        &#34;&#34;&#34;
        images = []
        for path in imagesPaths:
            images.append(self.loadImage(path))
        return images

    def setBgPic(self, bgPath: str):
        &#34;&#34;&#34;
        Cambia la imagen de fondo

        Args:
            bgPath (str): Ruta a la imagen a utilizar como fondo
        &#34;&#34;&#34;
        if bgPath:
            self.bgpic = self.loadImage(bgPath)
            self.canvas.itemconfig(self.bgpic_obj, image=self.bgpic)

    def gameLoop(self, fps: int):
        &#34;&#34;&#34;
        Inicia el loop principal del juego.

        Args:
            fps (int): Número de cuadros por segundo del juego.
        &#34;&#34;&#34;
        self.fps = fps
        self.fps_time = 1 / self.fps
        self.tick_prev = time.perf_counter()

        self.running = True
        self.win.protocol(&#34;WM_DELETE_WINDOW&#34;, self.exitGame)
        while self.running:
            self._doAddGameObjects()
            dt = self._doRefresh()
            self.onUpdate(dt)
            self._doUpdateGameObjects(dt)
            self._doCheckCollisions(dt)
            self._doDelGameObjects()
        self.win.destroy()
        self._instance_ = None

    def exitGame(self):
        &#34;&#34;&#34;
        Finaliza el loop principal del juego
        &#34;&#34;&#34;
        self.running = False

    def onUpdate(self, dt: float):
        &#34;&#34;&#34;
        Llamada por cada ciclo dentro del loop (fps veces por segundo)

        Args:
            dt (float): Tiempo en segundos desde la última llamada
        &#34;&#34;&#34;
        pass

    def _addGObject(self, gobj):
        if not hasattr(gobj, &#34;__status__&#34;):
            gobj.__status__ = &#34;new&#34;
            self.gObjects.append(gobj)
            for layer in range(1, self.numLayers + 1):
                self.canvas.tag_raise(&#34;Layer &#34; + str(layer))
            self.canvas.tag_raise(TextObject._layer_)


    def _doAddGameObjects(self):
        for o in self.gObjects:
            if o.__status__ == &#34;new&#34;:
                o.__status__ = &#34;alive&#34;

    def _delGObject(self, gobj):
        if hasattr(gobj, &#34;__status__&#34;):
            gobj.__status__ = &#34;dead&#34;

    def _doDelGameObjects(self):
        gobjs = [o for o in self.gObjects if o.__status__ == &#34;dead&#34;]
        for o in gobjs:
            self.gObjects.remove(o)

    def _doUpdateGameObjects(self, dt):
        for o in self.gObjects:
            if o.__status__ == &#34;alive&#34;:
                o.onUpdate(dt)

    def _doCheckCollisions(self, dt):
        gobjs1 = [o for o in self.gObjects if o.__status__ == &#34;alive&#34; and o.collisions]
        gobjs2 = gobjs1.copy()
        for o1 in gobjs1:
            gobjs2.pop(0)
            if o1.__status__ != &#34;alive&#34; or not o1.collisions:
                continue
            for o2 in gobjs2:
                if o2.__status__ != &#34;alive&#34; or not o2.collisions:
                    continue
                if self.collide(o1, o2):
                    o1.onCollision(dt, o2)
                    o2.onCollision(dt, o1)

    def collide(self, o1, o2) -&gt; bool:
        &#34;&#34;&#34;
        Detecta si dos GameObjects colisionan entre si

        Args:
            o1 (GameObject): El GameObject a verificar si colisiona con o2
            o2 (GameObject): El GameObject a verificar si colisiona con o1

        Returns:
            bool: True si colisionan. False en caso contrario.
        &#34;&#34;&#34;
        if o1 == o2:
            return False
        if o1.__status__ != &#34;alive&#34; or o2.__status__ != &#34;alive&#34;:
            return False

        o1x1 = o1.getX() - o1.getWidth() / 2
        o1y1 = o1.getY() - o1.getHeight() / 2
        o1x2 = o1x1 + o1.getWidth() - 1
        o1y2 = o1y1 + o1.getHeight() - 1

        o2x1 = o2.getX() - o2.getWidth() / 2
        o2y1 = o2.getY() - o2.getHeight() / 2
        o2x2 = o2x1 + o2.getWidth() - 1
        o2y2 = o2y1 + o2.getHeight() - 1

        return o1x1 &lt;= o2x2 and o2x1 &lt;= o1x2 and o1y1 &lt;= o2y2 and o2y1 &lt;= o1y2

    def _doRefresh(self):
        self.win.update_idletasks()
        self.win.update()

        while time.perf_counter() - self.tick_prev &lt; self.fps_time:
            _TIME_BEGIN_PERIOD(1)
            time.sleep(0)
            _TIME_END_PERIOD(1)

        now = time.perf_counter()
        dt = now - self.tick_prev
        self.tick_prev = now

        return dt

    def isPressed(self, key_name: str) -&gt; bool:
        &#34;&#34;&#34;
        Verifica si una tecla específica está siendo presionada.

        Args:
            key_name (str): Nombre de la tecla a verificar.

        Returns:
            bool: True si la tecla está presionada, False en caso contrario.
        &#34;&#34;&#34;
        if not key_name in self.keys:
            self.keys[key_name] = False
            self.win.bind(
                &#34;&lt;KeyPress-%s&gt;&#34; % key_name, lambda e: self._setPressed(key_name, True)
            )
            self.win.bind(
                &#34;&lt;KeyRelease-%s&gt;&#34; % key_name,
                lambda e: self._setPressed(key_name, False),
            )
        return self.keys[key_name]

    def _setPressed(self, key_name: str, pressed: bool):
        self.keys[key_name] = pressed

    def getWorldWidth(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene el ancho del mundo de juego.

        Returns:
            int: Ancho del mundo de juego.
        &#34;&#34;&#34;
        return self.win.winfo_width()

    def getWorldHeight(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la altura del mundo de juego.

        Returns:
            int: Altura del mundo de juego.
        &#34;&#34;&#34;
        return self.win.winfo_height()


# ---


class GameObject:
    def __init__(
        self,
        x: int,
        y: int,
        imagePath: str,
        tipo: str = &#34;undef&#34;,
        collisions: bool = False,
        layer: int = 1
    ):
        &#34;&#34;&#34;
        Constructor de la clase GameObject que inicializa un objeto en el mundo de juego.

        Args:
            x (int): Coordenada x inicial del objeto.
            y (int): Coordenada y inicial del objeto.
            imagePath (str): Ruta de la imagen del objeto.
            tipo (str, optional): Tipo del objeto (por defecto es &#34;undef&#34;).
            collisions (bool, optional): True si este objeto participara de las colisiones (por defecto es False)
            layer (int, optional): capa en que se colocara este objeto (por defecto es 1)
        &#34;&#34;&#34;
        self.gw = GameWorld._getInstance()
        if self.gw is None:
            raise (&#34;No existe una instancia de GameWorld activa!!!&#34;)
        canvas = self.gw._getCanvas()

        self.x = x
        self.y = y

        img = self.gw.loadImage(imagePath)
        self.width = img.width()
        self.height = img.height()
        self.shape = canvas.create_image(
            self.x,
            self.y,
            image=img,
            anchor=tk.CENTER,
            tags = (&#34;Layer &#34; + str(layer),)
        )

        self.tipo = tipo
        self.collisions = collisions
        self.gw._addGObject(self)

    def getX(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la coordenada x actual del objeto.

        Returns:
            int: Coordenada x del objeto.
        &#34;&#34;&#34;
        return self.x

    def getY(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la coordenada y actual del objeto.

        Returns:
            int: Coordenada y del objeto.
        &#34;&#34;&#34;
        return self.y

    def setPosition(self, x: int, y: int):
        &#34;&#34;&#34;
        Establece la posición del objeto en el mundo de juego.

        Args:
            x (int): Nueva coordenada x del objeto.
            y (int): Nueva coordenada y del objeto.
        &#34;&#34;&#34;
        x, y = int(x), int(y)
        dx = x - self.x
        dy = y - self.y
        self.gw._getCanvas().move(self.shape, dx, dy)
        self.x, self.y = x, y

    def setShape(self, imagePath: str):
        &#34;&#34;&#34;
        Cambia la forma del objeto reemplazando su imagen.

        Args:
            imagePath (str): Ruta de la nueva imagen del objeto.
        &#34;&#34;&#34;
        img = self.gw.loadImage(imagePath)
        self.width = img.width()
        self.height = img.height()
        self.gw._getCanvas().itemconfig(self.shape, image=img)
        self.setPosition(self.x, self.y)

    def getWidth(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene el ancho del objeto.

        Returns:
            int: Ancho del objeto.
        &#34;&#34;&#34;
        return self.width

    def getHeight(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la altura del objeto.

        Returns:
            int: Altura del objeto.
        &#34;&#34;&#34;
        return self.height

    def getTipo(self) -&gt; str:
        &#34;&#34;&#34;
        Obtiene el tipo del objeto.
        Returns:
            str: Tipo del objeto.
        &#34;&#34;&#34;
        return self.tipo

    def setCollisions(self, collisions: bool):
        &#34;&#34;&#34;
        Habilita o deshabilita participar del procesamiento de colisiones

        Args:
            collisions (bool): True para habilitar, False para deshabilitar
        &#34;&#34;&#34;
        self.collisions = collisions

    def destroy(self):
        &#34;&#34;&#34;
        Elimina el objeto del mundo de juego.
        &#34;&#34;&#34;
        self.gw._getCanvas().delete(self.shape)
        self.gw._delGObject(self)

    def collidesWith(self, obj) -&gt; bool:
        &#34;&#34;&#34;
        Determina si este GameObject colisiona con otro

        Args:
            obj (GameObject): GameObject a detectar si colision con este

        Returns:
            bool: True si colisiona. False en caso contrario
        &#34;&#34;&#34;
        return self.gw.collides(self, obj)

    def onUpdate(self, dt: float):
        &#34;&#34;&#34;
        Llamado en cada actualización del juego para el objeto.

        Args:
            dt (float): Tiempo en segundos desde la ultima llamada.
        &#34;&#34;&#34;
        pass

    def onCollision(self, dt: float, gobj):
        &#34;&#34;&#34;
        Llamado cuando el objeto colisiona con otro objeto.

        Args:
            dt (float): Tiempo en segundos desde la ultima llamada.
            gobj (GameObject): Objeto con el que colisiona.
        &#34;&#34;&#34;
        pass

    def getWorldWidth(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene el ancho del mundo de juego.

        Returns:
            int: Ancho del mundo de juego.
        &#34;&#34;&#34;
        return self.gw.getWorldWidth()

    def getWorldHeight(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la altura del mundo de juego.

        Returns:
            int: Altura del mundo de juego.
        &#34;&#34;&#34;
        return self.gw.getWorldHeight()

    def isPressed(self, key_name: str) -&gt; bool:
        &#34;&#34;&#34;
        Verifica si una tecla específica está siendo presionada.

        Args:
            key_name (str): Nombre de la tecla a verificar.

        Returns:
            bool: True si la tecla está siendo presionada, False en caso contrario.
        &#34;&#34;&#34;
        return self.gw.isPressed(key_name)

    def loadImage(self, imagePath: str) -&gt; tk.PhotoImage:
        &#34;&#34;&#34;
        Carga la imagen que se encuentra en la ruta especificada

        Args:
            imagePath (str): Ruta de la imagen a cargar.

        Returns:
            binary: La imagen a cargar.
        &#34;&#34;&#34;
        return self.gw.loadImage(imagePath)

    def loadImages(self, imagesPaths: list) -&gt; list:
        &#34;&#34;&#34;
        Carga las imagenes referenciadas por el arreglo de paths

        Args:
            imagesPaths (list): Arreglo de imagenes cargadas
        &#34;&#34;&#34;
        return self.gw.loadImages(imagesPaths)

    def setBgPic(self, bgPath: str):
        &#34;&#34;&#34;
        Cambia la imagen de fondo

        Args:
            bgPath (str): Ruta de la imagen a utilizar como fondo
        &#34;&#34;&#34;
        self.gw.setBgPic(bgPath)


# ---


class TextObject:
    _layer_ = &#34;TextObject&#34;
    def __init__(
        self,
        x: int,
        y: int,
        text: str,
        font: str = &#34;Arial&#34;,
        size: int = 10,
        bold: bool = False,
        italic: bool = False,
        color: str = &#34;black&#34;,
    ):
        &#34;&#34;&#34;
        Constructor de la clase TextObject que agrega un Texto al mundo del juego

        Args:
            x (int): Coordenada x del texto
            y (int): Coordenada y del texto
            text (str): Texto para este objeto
            font (str, optional): Font a utilizar para el texto (por defecto es &#34;Arial&#34;).
            size (int, optional): Tamano a utilizar para el texto (por defecto es 10).
            bold (bool, optional): Especifica que el texto estara en bold (por defecto es False).
            italic (bool, optional): Especifica que el texto estara en italic (por defecto es False).
            color (str, optional): Color a utilizar para el texto (por defecto es &#34;black&#34;).
        &#34;&#34;&#34;
        self.gw = GameWorld._getInstance()
        if self.gw is None:
            raise (&#34;No existe una instancia de GameWorld activa!!!&#34;)
        canvas = self.gw._getCanvas()

        self.text = canvas.create_text(0, 0, text=text, anchor=tk.NW, tags=(TextObject._layer_,))
        self.setText(x, y, text, font, size, bold, italic, color)
        canvas.tag_raise(TextObject._layer_)

    def setText(
        self,
        x: int = None,
        y: int = None,
        text: str = None,
        font: str = None,
        size: int = None,
        bold: bool = None,
        italic: bool = None,
        color: str = None,
    ):
        &#34;&#34;&#34;
        Modifica el texto desplegado y sus atributos. Si no se especifican atributos se convservan los existentes

        Args:
            x (int, optional): Coordenada x del texto.
            y (int, optional): Coordenada y del texto
            text (str, optional): Texto para este objeto
            font (str, optional): Font a utilizar para el texto
            size (int, optional): Tamano a utilizar para el texto
            bold (bool, optional): Especifica que el texto estara en bold
            italic (bool, optional): Especifica que el texto estara en italic
            color (str, optional): Color a utilizar para el texto
        &#34;&#34;&#34;
        canvas = self.gw._getCanvas()

        # la posicion del texto
        _x, _y = canvas.coords(self.text)
        if x is None:
            x = _x
        if y is None:
            y = _y
        x, y = int(x), int(y)
        dx = x - _x
        dy = y - _y
        canvas.move(self.text, dx, dy)

        # los atributos
        kwargs = {}
        if not text is None:
            kwargs[&#34;text&#34;] = text
        f = []
        if not font is None:
            f.append(font)
        if not size is None:
            f.append(size)
        t = &#34;&#34;
        if bold:
            t = t + &#34; bold &#34;
        if italic:
            t = t + &#34; italic &#34;
        if t:
            f.append(t)
        if f:
            kwargs[&#34;font&#34;] = tuple(f)
        if not color is None:
            kwargs[&#34;fill&#34;] = color
        canvas.itemconfig(self.text, kwargs)

    def destroy(self):
        &#34;&#34;&#34;
        Elimina este texto del mundo del juego
        &#34;&#34;&#34;
        self.gw._getCanvas().delete(self.text)
        self.text = None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MiniGameEngine.GameObject"><code class="flex name class">
<span>class <span class="ident">GameObject</span></span>
<span>(</span><span>x: int, y: int, imagePath: str, tipo: str = 'undef', collisions: bool = False, layer: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructor de la clase GameObject que inicializa un objeto en el mundo de juego.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Coordenada x inicial del objeto.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Coordenada y inicial del objeto.</dd>
<dt><strong><code>imagePath</code></strong> :&ensp;<code>str</code></dt>
<dd>Ruta de la imagen del objeto.</dd>
<dt><strong><code>tipo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Tipo del objeto (por defecto es "undef").</dd>
<dt><strong><code>collisions</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>True si este objeto participara de las colisiones (por defecto es False)</dd>
<dt><strong><code>layer</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>capa en que se colocara este objeto (por defecto es 1)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameObject:
    def __init__(
        self,
        x: int,
        y: int,
        imagePath: str,
        tipo: str = &#34;undef&#34;,
        collisions: bool = False,
        layer: int = 1
    ):
        &#34;&#34;&#34;
        Constructor de la clase GameObject que inicializa un objeto en el mundo de juego.

        Args:
            x (int): Coordenada x inicial del objeto.
            y (int): Coordenada y inicial del objeto.
            imagePath (str): Ruta de la imagen del objeto.
            tipo (str, optional): Tipo del objeto (por defecto es &#34;undef&#34;).
            collisions (bool, optional): True si este objeto participara de las colisiones (por defecto es False)
            layer (int, optional): capa en que se colocara este objeto (por defecto es 1)
        &#34;&#34;&#34;
        self.gw = GameWorld._getInstance()
        if self.gw is None:
            raise (&#34;No existe una instancia de GameWorld activa!!!&#34;)
        canvas = self.gw._getCanvas()

        self.x = x
        self.y = y

        img = self.gw.loadImage(imagePath)
        self.width = img.width()
        self.height = img.height()
        self.shape = canvas.create_image(
            self.x,
            self.y,
            image=img,
            anchor=tk.CENTER,
            tags = (&#34;Layer &#34; + str(layer),)
        )

        self.tipo = tipo
        self.collisions = collisions
        self.gw._addGObject(self)

    def getX(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la coordenada x actual del objeto.

        Returns:
            int: Coordenada x del objeto.
        &#34;&#34;&#34;
        return self.x

    def getY(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la coordenada y actual del objeto.

        Returns:
            int: Coordenada y del objeto.
        &#34;&#34;&#34;
        return self.y

    def setPosition(self, x: int, y: int):
        &#34;&#34;&#34;
        Establece la posición del objeto en el mundo de juego.

        Args:
            x (int): Nueva coordenada x del objeto.
            y (int): Nueva coordenada y del objeto.
        &#34;&#34;&#34;
        x, y = int(x), int(y)
        dx = x - self.x
        dy = y - self.y
        self.gw._getCanvas().move(self.shape, dx, dy)
        self.x, self.y = x, y

    def setShape(self, imagePath: str):
        &#34;&#34;&#34;
        Cambia la forma del objeto reemplazando su imagen.

        Args:
            imagePath (str): Ruta de la nueva imagen del objeto.
        &#34;&#34;&#34;
        img = self.gw.loadImage(imagePath)
        self.width = img.width()
        self.height = img.height()
        self.gw._getCanvas().itemconfig(self.shape, image=img)
        self.setPosition(self.x, self.y)

    def getWidth(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene el ancho del objeto.

        Returns:
            int: Ancho del objeto.
        &#34;&#34;&#34;
        return self.width

    def getHeight(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la altura del objeto.

        Returns:
            int: Altura del objeto.
        &#34;&#34;&#34;
        return self.height

    def getTipo(self) -&gt; str:
        &#34;&#34;&#34;
        Obtiene el tipo del objeto.
        Returns:
            str: Tipo del objeto.
        &#34;&#34;&#34;
        return self.tipo

    def setCollisions(self, collisions: bool):
        &#34;&#34;&#34;
        Habilita o deshabilita participar del procesamiento de colisiones

        Args:
            collisions (bool): True para habilitar, False para deshabilitar
        &#34;&#34;&#34;
        self.collisions = collisions

    def destroy(self):
        &#34;&#34;&#34;
        Elimina el objeto del mundo de juego.
        &#34;&#34;&#34;
        self.gw._getCanvas().delete(self.shape)
        self.gw._delGObject(self)

    def collidesWith(self, obj) -&gt; bool:
        &#34;&#34;&#34;
        Determina si este GameObject colisiona con otro

        Args:
            obj (GameObject): GameObject a detectar si colision con este

        Returns:
            bool: True si colisiona. False en caso contrario
        &#34;&#34;&#34;
        return self.gw.collides(self, obj)

    def onUpdate(self, dt: float):
        &#34;&#34;&#34;
        Llamado en cada actualización del juego para el objeto.

        Args:
            dt (float): Tiempo en segundos desde la ultima llamada.
        &#34;&#34;&#34;
        pass

    def onCollision(self, dt: float, gobj):
        &#34;&#34;&#34;
        Llamado cuando el objeto colisiona con otro objeto.

        Args:
            dt (float): Tiempo en segundos desde la ultima llamada.
            gobj (GameObject): Objeto con el que colisiona.
        &#34;&#34;&#34;
        pass

    def getWorldWidth(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene el ancho del mundo de juego.

        Returns:
            int: Ancho del mundo de juego.
        &#34;&#34;&#34;
        return self.gw.getWorldWidth()

    def getWorldHeight(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la altura del mundo de juego.

        Returns:
            int: Altura del mundo de juego.
        &#34;&#34;&#34;
        return self.gw.getWorldHeight()

    def isPressed(self, key_name: str) -&gt; bool:
        &#34;&#34;&#34;
        Verifica si una tecla específica está siendo presionada.

        Args:
            key_name (str): Nombre de la tecla a verificar.

        Returns:
            bool: True si la tecla está siendo presionada, False en caso contrario.
        &#34;&#34;&#34;
        return self.gw.isPressed(key_name)

    def loadImage(self, imagePath: str) -&gt; tk.PhotoImage:
        &#34;&#34;&#34;
        Carga la imagen que se encuentra en la ruta especificada

        Args:
            imagePath (str): Ruta de la imagen a cargar.

        Returns:
            binary: La imagen a cargar.
        &#34;&#34;&#34;
        return self.gw.loadImage(imagePath)

    def loadImages(self, imagesPaths: list) -&gt; list:
        &#34;&#34;&#34;
        Carga las imagenes referenciadas por el arreglo de paths

        Args:
            imagesPaths (list): Arreglo de imagenes cargadas
        &#34;&#34;&#34;
        return self.gw.loadImages(imagesPaths)

    def setBgPic(self, bgPath: str):
        &#34;&#34;&#34;
        Cambia la imagen de fondo

        Args:
            bgPath (str): Ruta de la imagen a utilizar como fondo
        &#34;&#34;&#34;
        self.gw.setBgPic(bgPath)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MiniGameEngine.GameObject.collidesWith"><code class="name flex">
<span>def <span class="ident">collidesWith</span></span>(<span>self, obj) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determina si este GameObject colisiona con otro</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code><a title="MiniGameEngine.GameObject" href="#MiniGameEngine.GameObject">GameObject</a></code></dt>
<dd>GameObject a detectar si colision con este</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True si colisiona. False en caso contrario</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collidesWith(self, obj) -&gt; bool:
    &#34;&#34;&#34;
    Determina si este GameObject colisiona con otro

    Args:
        obj (GameObject): GameObject a detectar si colision con este

    Returns:
        bool: True si colisiona. False en caso contrario
    &#34;&#34;&#34;
    return self.gw.collides(self, obj)</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Elimina el objeto del mundo de juego.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Elimina el objeto del mundo de juego.
    &#34;&#34;&#34;
    self.gw._getCanvas().delete(self.shape)
    self.gw._delGObject(self)</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getHeight"><code class="name flex">
<span>def <span class="ident">getHeight</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene la altura del objeto.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Altura del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHeight(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene la altura del objeto.

    Returns:
        int: Altura del objeto.
    &#34;&#34;&#34;
    return self.height</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getTipo"><code class="name flex">
<span>def <span class="ident">getTipo</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene el tipo del objeto.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Tipo del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTipo(self) -&gt; str:
    &#34;&#34;&#34;
    Obtiene el tipo del objeto.
    Returns:
        str: Tipo del objeto.
    &#34;&#34;&#34;
    return self.tipo</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getWidth"><code class="name flex">
<span>def <span class="ident">getWidth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene el ancho del objeto.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Ancho del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWidth(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene el ancho del objeto.

    Returns:
        int: Ancho del objeto.
    &#34;&#34;&#34;
    return self.width</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getWorldHeight"><code class="name flex">
<span>def <span class="ident">getWorldHeight</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene la altura del mundo de juego.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Altura del mundo de juego.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWorldHeight(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene la altura del mundo de juego.

    Returns:
        int: Altura del mundo de juego.
    &#34;&#34;&#34;
    return self.gw.getWorldHeight()</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getWorldWidth"><code class="name flex">
<span>def <span class="ident">getWorldWidth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene el ancho del mundo de juego.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Ancho del mundo de juego.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWorldWidth(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene el ancho del mundo de juego.

    Returns:
        int: Ancho del mundo de juego.
    &#34;&#34;&#34;
    return self.gw.getWorldWidth()</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getX"><code class="name flex">
<span>def <span class="ident">getX</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene la coordenada x actual del objeto.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Coordenada x del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getX(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene la coordenada x actual del objeto.

    Returns:
        int: Coordenada x del objeto.
    &#34;&#34;&#34;
    return self.x</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.getY"><code class="name flex">
<span>def <span class="ident">getY</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene la coordenada y actual del objeto.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Coordenada y del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getY(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene la coordenada y actual del objeto.

    Returns:
        int: Coordenada y del objeto.
    &#34;&#34;&#34;
    return self.y</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.isPressed"><code class="name flex">
<span>def <span class="ident">isPressed</span></span>(<span>self, key_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verifica si una tecla específica está siendo presionada.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Nombre de la tecla a verificar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True si la tecla está siendo presionada, False en caso contrario.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isPressed(self, key_name: str) -&gt; bool:
    &#34;&#34;&#34;
    Verifica si una tecla específica está siendo presionada.

    Args:
        key_name (str): Nombre de la tecla a verificar.

    Returns:
        bool: True si la tecla está siendo presionada, False en caso contrario.
    &#34;&#34;&#34;
    return self.gw.isPressed(key_name)</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.loadImage"><code class="name flex">
<span>def <span class="ident">loadImage</span></span>(<span>self, imagePath: str) ‑> tkinter.PhotoImage</span>
</code></dt>
<dd>
<div class="desc"><p>Carga la imagen que se encuentra en la ruta especificada</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imagePath</code></strong> :&ensp;<code>str</code></dt>
<dd>Ruta de la imagen a cargar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>binary</code></dt>
<dd>La imagen a cargar.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadImage(self, imagePath: str) -&gt; tk.PhotoImage:
    &#34;&#34;&#34;
    Carga la imagen que se encuentra en la ruta especificada

    Args:
        imagePath (str): Ruta de la imagen a cargar.

    Returns:
        binary: La imagen a cargar.
    &#34;&#34;&#34;
    return self.gw.loadImage(imagePath)</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.loadImages"><code class="name flex">
<span>def <span class="ident">loadImages</span></span>(<span>self, imagesPaths: list) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Carga las imagenes referenciadas por el arreglo de paths</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imagesPaths</code></strong> :&ensp;<code>list</code></dt>
<dd>Arreglo de imagenes cargadas</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadImages(self, imagesPaths: list) -&gt; list:
    &#34;&#34;&#34;
    Carga las imagenes referenciadas por el arreglo de paths

    Args:
        imagesPaths (list): Arreglo de imagenes cargadas
    &#34;&#34;&#34;
    return self.gw.loadImages(imagesPaths)</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.onCollision"><code class="name flex">
<span>def <span class="ident">onCollision</span></span>(<span>self, dt: float, gobj)</span>
</code></dt>
<dd>
<div class="desc"><p>Llamado cuando el objeto colisiona con otro objeto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en segundos desde la ultima llamada.</dd>
<dt><strong><code>gobj</code></strong> :&ensp;<code><a title="MiniGameEngine.GameObject" href="#MiniGameEngine.GameObject">GameObject</a></code></dt>
<dd>Objeto con el que colisiona.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onCollision(self, dt: float, gobj):
    &#34;&#34;&#34;
    Llamado cuando el objeto colisiona con otro objeto.

    Args:
        dt (float): Tiempo en segundos desde la ultima llamada.
        gobj (GameObject): Objeto con el que colisiona.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.onUpdate"><code class="name flex">
<span>def <span class="ident">onUpdate</span></span>(<span>self, dt: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Llamado en cada actualización del juego para el objeto.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en segundos desde la ultima llamada.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onUpdate(self, dt: float):
    &#34;&#34;&#34;
    Llamado en cada actualización del juego para el objeto.

    Args:
        dt (float): Tiempo en segundos desde la ultima llamada.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.setBgPic"><code class="name flex">
<span>def <span class="ident">setBgPic</span></span>(<span>self, bgPath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Cambia la imagen de fondo</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bgPath</code></strong> :&ensp;<code>str</code></dt>
<dd>Ruta de la imagen a utilizar como fondo</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBgPic(self, bgPath: str):
    &#34;&#34;&#34;
    Cambia la imagen de fondo

    Args:
        bgPath (str): Ruta de la imagen a utilizar como fondo
    &#34;&#34;&#34;
    self.gw.setBgPic(bgPath)</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.setCollisions"><code class="name flex">
<span>def <span class="ident">setCollisions</span></span>(<span>self, collisions: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Habilita o deshabilita participar del procesamiento de colisiones</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>collisions</code></strong> :&ensp;<code>bool</code></dt>
<dd>True para habilitar, False para deshabilitar</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCollisions(self, collisions: bool):
    &#34;&#34;&#34;
    Habilita o deshabilita participar del procesamiento de colisiones

    Args:
        collisions (bool): True para habilitar, False para deshabilitar
    &#34;&#34;&#34;
    self.collisions = collisions</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.setPosition"><code class="name flex">
<span>def <span class="ident">setPosition</span></span>(<span>self, x: int, y: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Establece la posición del objeto en el mundo de juego.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Nueva coordenada x del objeto.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Nueva coordenada y del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setPosition(self, x: int, y: int):
    &#34;&#34;&#34;
    Establece la posición del objeto en el mundo de juego.

    Args:
        x (int): Nueva coordenada x del objeto.
        y (int): Nueva coordenada y del objeto.
    &#34;&#34;&#34;
    x, y = int(x), int(y)
    dx = x - self.x
    dy = y - self.y
    self.gw._getCanvas().move(self.shape, dx, dy)
    self.x, self.y = x, y</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameObject.setShape"><code class="name flex">
<span>def <span class="ident">setShape</span></span>(<span>self, imagePath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Cambia la forma del objeto reemplazando su imagen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imagePath</code></strong> :&ensp;<code>str</code></dt>
<dd>Ruta de la nueva imagen del objeto.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setShape(self, imagePath: str):
    &#34;&#34;&#34;
    Cambia la forma del objeto reemplazando su imagen.

    Args:
        imagePath (str): Ruta de la nueva imagen del objeto.
    &#34;&#34;&#34;
    img = self.gw.loadImage(imagePath)
    self.width = img.width()
    self.height = img.height()
    self.gw._getCanvas().itemconfig(self.shape, image=img)
    self.setPosition(self.x, self.y)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MiniGameEngine.GameWorld"><code class="flex name class">
<span>class <span class="ident">GameWorld</span></span>
<span>(</span><span>width: int, height: int, title: str = 'MiniGameEngine', bgColor: str = 'gray', bgPath: str = None, numLayers: int = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Constructor de la clase GameWorld que inicializa una instancia del mundo de juego.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>Ancho de la ventana del juego.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>Altura de la ventana del juego.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Título de la ventana del juego (por defecto es "MiniGameEngine").</dd>
<dt><strong><code>bgColor</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color de fondo de la ventana del juego (por defecto es "gray").</dd>
<dt><strong><code>bgPath</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ruta de la imagen de fondo de la ventana del juego (por defecto es None).</dd>
<dt><strong><code>numLayers</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Numero de capas a permitir en el juego (por defecto es 10).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameWorld:
    _instance_ = None

    def _getInstance():
        return GameWorld._instance_

    # ---

    def __init__(
        self,
        width: int,
        height: int,
        title: str = &#34;MiniGameEngine&#34;,
        bgColor: str = &#34;gray&#34;,
        bgPath: str = None,
        numLayers: int = 10,
    ):
        &#34;&#34;&#34;
        Constructor de la clase GameWorld que inicializa una instancia del mundo de juego.

        Args:
            width (int): Ancho de la ventana del juego.
            height (int): Altura de la ventana del juego.
            title (str, optional): Título de la ventana del juego (por defecto es &#34;MiniGameEngine&#34;).
            bgColor (str, optional): Color de fondo de la ventana del juego (por defecto es &#34;gray&#34;).
            bgPath (str, optional): Ruta de la imagen de fondo de la ventana del juego (por defecto es None).
            numLayers (int, optional): Numero de capas a permitir en el juego (por defecto es 10).
        &#34;&#34;&#34;
        if not GameWorld._instance_ is None:
            raise Exception(&#34;Ya existe una instancia de GameWorld activa!!!&#34;)

        self.win = tk.Tk()
        self.win.geometry(&#34;%dx%d&#34; % (width, height))
        self.win.title(title)
        self.win.resizable(False, False)

        self.canvas = tk.Canvas(self.win, width=width, height=height, bg=bgColor)
        self.canvas.place(x=0, y=0)

        self.images = {}
        self.bgpic = None
        self.bgpic_obj = self.canvas.create_image(0, 0, anchor=tk.NW)
        self.setBgPic(bgPath)

        self.numLayers = numLayers

        self.keys = {}
        self.tick_prev = 0
        self.fps = 0
        self.gObjects = []
        self.running = False
        GameWorld._instance_ = self

    def _getCanvas(self) -&gt; tk.Canvas:
        return self.canvas

    def loadImage(self, imagePath: str) -&gt; tk.PhotoImage:
        &#34;&#34;&#34;
        Carga la imagen que se encuentra en la ruta especificada

        Args:
            imagePath (str): Ruta de la imagen a cargar.

        Returns:
            binary: La imagen cargada.
        &#34;&#34;&#34;
        if not imagePath in self.images:
            self.images[imagePath] = tk.PhotoImage(file=imagePath)
        return self.images[imagePath]

    def loadImages(self, imagesPaths: list) -&gt; list:
        &#34;&#34;&#34;
        Carga las imagenes referenciadas por el arreglo de rutas

        Args:
            imagesPaths (list): Arreglo de rutas a las imagenes a cargar.

        Returns:
            list : Arreglo con las imágenes cargadas.
        &#34;&#34;&#34;
        images = []
        for path in imagesPaths:
            images.append(self.loadImage(path))
        return images

    def setBgPic(self, bgPath: str):
        &#34;&#34;&#34;
        Cambia la imagen de fondo

        Args:
            bgPath (str): Ruta a la imagen a utilizar como fondo
        &#34;&#34;&#34;
        if bgPath:
            self.bgpic = self.loadImage(bgPath)
            self.canvas.itemconfig(self.bgpic_obj, image=self.bgpic)

    def gameLoop(self, fps: int):
        &#34;&#34;&#34;
        Inicia el loop principal del juego.

        Args:
            fps (int): Número de cuadros por segundo del juego.
        &#34;&#34;&#34;
        self.fps = fps
        self.fps_time = 1 / self.fps
        self.tick_prev = time.perf_counter()

        self.running = True
        self.win.protocol(&#34;WM_DELETE_WINDOW&#34;, self.exitGame)
        while self.running:
            self._doAddGameObjects()
            dt = self._doRefresh()
            self.onUpdate(dt)
            self._doUpdateGameObjects(dt)
            self._doCheckCollisions(dt)
            self._doDelGameObjects()
        self.win.destroy()
        self._instance_ = None

    def exitGame(self):
        &#34;&#34;&#34;
        Finaliza el loop principal del juego
        &#34;&#34;&#34;
        self.running = False

    def onUpdate(self, dt: float):
        &#34;&#34;&#34;
        Llamada por cada ciclo dentro del loop (fps veces por segundo)

        Args:
            dt (float): Tiempo en segundos desde la última llamada
        &#34;&#34;&#34;
        pass

    def _addGObject(self, gobj):
        if not hasattr(gobj, &#34;__status__&#34;):
            gobj.__status__ = &#34;new&#34;
            self.gObjects.append(gobj)
            for layer in range(1, self.numLayers + 1):
                self.canvas.tag_raise(&#34;Layer &#34; + str(layer))
            self.canvas.tag_raise(TextObject._layer_)


    def _doAddGameObjects(self):
        for o in self.gObjects:
            if o.__status__ == &#34;new&#34;:
                o.__status__ = &#34;alive&#34;

    def _delGObject(self, gobj):
        if hasattr(gobj, &#34;__status__&#34;):
            gobj.__status__ = &#34;dead&#34;

    def _doDelGameObjects(self):
        gobjs = [o for o in self.gObjects if o.__status__ == &#34;dead&#34;]
        for o in gobjs:
            self.gObjects.remove(o)

    def _doUpdateGameObjects(self, dt):
        for o in self.gObjects:
            if o.__status__ == &#34;alive&#34;:
                o.onUpdate(dt)

    def _doCheckCollisions(self, dt):
        gobjs1 = [o for o in self.gObjects if o.__status__ == &#34;alive&#34; and o.collisions]
        gobjs2 = gobjs1.copy()
        for o1 in gobjs1:
            gobjs2.pop(0)
            if o1.__status__ != &#34;alive&#34; or not o1.collisions:
                continue
            for o2 in gobjs2:
                if o2.__status__ != &#34;alive&#34; or not o2.collisions:
                    continue
                if self.collide(o1, o2):
                    o1.onCollision(dt, o2)
                    o2.onCollision(dt, o1)

    def collide(self, o1, o2) -&gt; bool:
        &#34;&#34;&#34;
        Detecta si dos GameObjects colisionan entre si

        Args:
            o1 (GameObject): El GameObject a verificar si colisiona con o2
            o2 (GameObject): El GameObject a verificar si colisiona con o1

        Returns:
            bool: True si colisionan. False en caso contrario.
        &#34;&#34;&#34;
        if o1 == o2:
            return False
        if o1.__status__ != &#34;alive&#34; or o2.__status__ != &#34;alive&#34;:
            return False

        o1x1 = o1.getX() - o1.getWidth() / 2
        o1y1 = o1.getY() - o1.getHeight() / 2
        o1x2 = o1x1 + o1.getWidth() - 1
        o1y2 = o1y1 + o1.getHeight() - 1

        o2x1 = o2.getX() - o2.getWidth() / 2
        o2y1 = o2.getY() - o2.getHeight() / 2
        o2x2 = o2x1 + o2.getWidth() - 1
        o2y2 = o2y1 + o2.getHeight() - 1

        return o1x1 &lt;= o2x2 and o2x1 &lt;= o1x2 and o1y1 &lt;= o2y2 and o2y1 &lt;= o1y2

    def _doRefresh(self):
        self.win.update_idletasks()
        self.win.update()

        while time.perf_counter() - self.tick_prev &lt; self.fps_time:
            _TIME_BEGIN_PERIOD(1)
            time.sleep(0)
            _TIME_END_PERIOD(1)

        now = time.perf_counter()
        dt = now - self.tick_prev
        self.tick_prev = now

        return dt

    def isPressed(self, key_name: str) -&gt; bool:
        &#34;&#34;&#34;
        Verifica si una tecla específica está siendo presionada.

        Args:
            key_name (str): Nombre de la tecla a verificar.

        Returns:
            bool: True si la tecla está presionada, False en caso contrario.
        &#34;&#34;&#34;
        if not key_name in self.keys:
            self.keys[key_name] = False
            self.win.bind(
                &#34;&lt;KeyPress-%s&gt;&#34; % key_name, lambda e: self._setPressed(key_name, True)
            )
            self.win.bind(
                &#34;&lt;KeyRelease-%s&gt;&#34; % key_name,
                lambda e: self._setPressed(key_name, False),
            )
        return self.keys[key_name]

    def _setPressed(self, key_name: str, pressed: bool):
        self.keys[key_name] = pressed

    def getWorldWidth(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene el ancho del mundo de juego.

        Returns:
            int: Ancho del mundo de juego.
        &#34;&#34;&#34;
        return self.win.winfo_width()

    def getWorldHeight(self) -&gt; int:
        &#34;&#34;&#34;
        Obtiene la altura del mundo de juego.

        Returns:
            int: Altura del mundo de juego.
        &#34;&#34;&#34;
        return self.win.winfo_height()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MiniGameEngine.GameWorld.collide"><code class="name flex">
<span>def <span class="ident">collide</span></span>(<span>self, o1, o2) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Detecta si dos GameObjects colisionan entre si</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>o1</code></strong> :&ensp;<code><a title="MiniGameEngine.GameObject" href="#MiniGameEngine.GameObject">GameObject</a></code></dt>
<dd>El GameObject a verificar si colisiona con o2</dd>
<dt><strong><code>o2</code></strong> :&ensp;<code><a title="MiniGameEngine.GameObject" href="#MiniGameEngine.GameObject">GameObject</a></code></dt>
<dd>El GameObject a verificar si colisiona con o1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True si colisionan. False en caso contrario.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collide(self, o1, o2) -&gt; bool:
    &#34;&#34;&#34;
    Detecta si dos GameObjects colisionan entre si

    Args:
        o1 (GameObject): El GameObject a verificar si colisiona con o2
        o2 (GameObject): El GameObject a verificar si colisiona con o1

    Returns:
        bool: True si colisionan. False en caso contrario.
    &#34;&#34;&#34;
    if o1 == o2:
        return False
    if o1.__status__ != &#34;alive&#34; or o2.__status__ != &#34;alive&#34;:
        return False

    o1x1 = o1.getX() - o1.getWidth() / 2
    o1y1 = o1.getY() - o1.getHeight() / 2
    o1x2 = o1x1 + o1.getWidth() - 1
    o1y2 = o1y1 + o1.getHeight() - 1

    o2x1 = o2.getX() - o2.getWidth() / 2
    o2y1 = o2.getY() - o2.getHeight() / 2
    o2x2 = o2x1 + o2.getWidth() - 1
    o2y2 = o2y1 + o2.getHeight() - 1

    return o1x1 &lt;= o2x2 and o2x1 &lt;= o1x2 and o1y1 &lt;= o2y2 and o2y1 &lt;= o1y2</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.exitGame"><code class="name flex">
<span>def <span class="ident">exitGame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finaliza el loop principal del juego</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exitGame(self):
    &#34;&#34;&#34;
    Finaliza el loop principal del juego
    &#34;&#34;&#34;
    self.running = False</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.gameLoop"><code class="name flex">
<span>def <span class="ident">gameLoop</span></span>(<span>self, fps: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Inicia el loop principal del juego.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fps</code></strong> :&ensp;<code>int</code></dt>
<dd>Número de cuadros por segundo del juego.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gameLoop(self, fps: int):
    &#34;&#34;&#34;
    Inicia el loop principal del juego.

    Args:
        fps (int): Número de cuadros por segundo del juego.
    &#34;&#34;&#34;
    self.fps = fps
    self.fps_time = 1 / self.fps
    self.tick_prev = time.perf_counter()

    self.running = True
    self.win.protocol(&#34;WM_DELETE_WINDOW&#34;, self.exitGame)
    while self.running:
        self._doAddGameObjects()
        dt = self._doRefresh()
        self.onUpdate(dt)
        self._doUpdateGameObjects(dt)
        self._doCheckCollisions(dt)
        self._doDelGameObjects()
    self.win.destroy()
    self._instance_ = None</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.getWorldHeight"><code class="name flex">
<span>def <span class="ident">getWorldHeight</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene la altura del mundo de juego.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Altura del mundo de juego.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWorldHeight(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene la altura del mundo de juego.

    Returns:
        int: Altura del mundo de juego.
    &#34;&#34;&#34;
    return self.win.winfo_height()</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.getWorldWidth"><code class="name flex">
<span>def <span class="ident">getWorldWidth</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Obtiene el ancho del mundo de juego.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Ancho del mundo de juego.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getWorldWidth(self) -&gt; int:
    &#34;&#34;&#34;
    Obtiene el ancho del mundo de juego.

    Returns:
        int: Ancho del mundo de juego.
    &#34;&#34;&#34;
    return self.win.winfo_width()</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.isPressed"><code class="name flex">
<span>def <span class="ident">isPressed</span></span>(<span>self, key_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verifica si una tecla específica está siendo presionada.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Nombre de la tecla a verificar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True si la tecla está presionada, False en caso contrario.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isPressed(self, key_name: str) -&gt; bool:
    &#34;&#34;&#34;
    Verifica si una tecla específica está siendo presionada.

    Args:
        key_name (str): Nombre de la tecla a verificar.

    Returns:
        bool: True si la tecla está presionada, False en caso contrario.
    &#34;&#34;&#34;
    if not key_name in self.keys:
        self.keys[key_name] = False
        self.win.bind(
            &#34;&lt;KeyPress-%s&gt;&#34; % key_name, lambda e: self._setPressed(key_name, True)
        )
        self.win.bind(
            &#34;&lt;KeyRelease-%s&gt;&#34; % key_name,
            lambda e: self._setPressed(key_name, False),
        )
    return self.keys[key_name]</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.loadImage"><code class="name flex">
<span>def <span class="ident">loadImage</span></span>(<span>self, imagePath: str) ‑> tkinter.PhotoImage</span>
</code></dt>
<dd>
<div class="desc"><p>Carga la imagen que se encuentra en la ruta especificada</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imagePath</code></strong> :&ensp;<code>str</code></dt>
<dd>Ruta de la imagen a cargar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>binary</code></dt>
<dd>La imagen cargada.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadImage(self, imagePath: str) -&gt; tk.PhotoImage:
    &#34;&#34;&#34;
    Carga la imagen que se encuentra en la ruta especificada

    Args:
        imagePath (str): Ruta de la imagen a cargar.

    Returns:
        binary: La imagen cargada.
    &#34;&#34;&#34;
    if not imagePath in self.images:
        self.images[imagePath] = tk.PhotoImage(file=imagePath)
    return self.images[imagePath]</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.loadImages"><code class="name flex">
<span>def <span class="ident">loadImages</span></span>(<span>self, imagesPaths: list) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Carga las imagenes referenciadas por el arreglo de rutas</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>imagesPaths</code></strong> :&ensp;<code>list</code></dt>
<dd>Arreglo de rutas a las imagenes a cargar.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list </code></dt>
<dd>Arreglo con las imágenes cargadas.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadImages(self, imagesPaths: list) -&gt; list:
    &#34;&#34;&#34;
    Carga las imagenes referenciadas por el arreglo de rutas

    Args:
        imagesPaths (list): Arreglo de rutas a las imagenes a cargar.

    Returns:
        list : Arreglo con las imágenes cargadas.
    &#34;&#34;&#34;
    images = []
    for path in imagesPaths:
        images.append(self.loadImage(path))
    return images</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.onUpdate"><code class="name flex">
<span>def <span class="ident">onUpdate</span></span>(<span>self, dt: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Llamada por cada ciclo dentro del loop (fps veces por segundo)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code></dt>
<dd>Tiempo en segundos desde la última llamada</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onUpdate(self, dt: float):
    &#34;&#34;&#34;
    Llamada por cada ciclo dentro del loop (fps veces por segundo)

    Args:
        dt (float): Tiempo en segundos desde la última llamada
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.GameWorld.setBgPic"><code class="name flex">
<span>def <span class="ident">setBgPic</span></span>(<span>self, bgPath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Cambia la imagen de fondo</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bgPath</code></strong> :&ensp;<code>str</code></dt>
<dd>Ruta a la imagen a utilizar como fondo</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBgPic(self, bgPath: str):
    &#34;&#34;&#34;
    Cambia la imagen de fondo

    Args:
        bgPath (str): Ruta a la imagen a utilizar como fondo
    &#34;&#34;&#34;
    if bgPath:
        self.bgpic = self.loadImage(bgPath)
        self.canvas.itemconfig(self.bgpic_obj, image=self.bgpic)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MiniGameEngine.TextObject"><code class="flex name class">
<span>class <span class="ident">TextObject</span></span>
<span>(</span><span>x: int, y: int, text: str, font: str = 'Arial', size: int = 10, bold: bool = False, italic: bool = False, color: str = 'black')</span>
</code></dt>
<dd>
<div class="desc"><p>Constructor de la clase TextObject que agrega un Texto al mundo del juego</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Coordenada x del texto</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Coordenada y del texto</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Texto para este objeto</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Font a utilizar para el texto (por defecto es "Arial").</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Tamano a utilizar para el texto (por defecto es 10).</dd>
<dt><strong><code>bold</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Especifica que el texto estara en bold (por defecto es False).</dd>
<dt><strong><code>italic</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Especifica que el texto estara en italic (por defecto es False).</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color a utilizar para el texto (por defecto es "black").</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextObject:
    _layer_ = &#34;TextObject&#34;
    def __init__(
        self,
        x: int,
        y: int,
        text: str,
        font: str = &#34;Arial&#34;,
        size: int = 10,
        bold: bool = False,
        italic: bool = False,
        color: str = &#34;black&#34;,
    ):
        &#34;&#34;&#34;
        Constructor de la clase TextObject que agrega un Texto al mundo del juego

        Args:
            x (int): Coordenada x del texto
            y (int): Coordenada y del texto
            text (str): Texto para este objeto
            font (str, optional): Font a utilizar para el texto (por defecto es &#34;Arial&#34;).
            size (int, optional): Tamano a utilizar para el texto (por defecto es 10).
            bold (bool, optional): Especifica que el texto estara en bold (por defecto es False).
            italic (bool, optional): Especifica que el texto estara en italic (por defecto es False).
            color (str, optional): Color a utilizar para el texto (por defecto es &#34;black&#34;).
        &#34;&#34;&#34;
        self.gw = GameWorld._getInstance()
        if self.gw is None:
            raise (&#34;No existe una instancia de GameWorld activa!!!&#34;)
        canvas = self.gw._getCanvas()

        self.text = canvas.create_text(0, 0, text=text, anchor=tk.NW, tags=(TextObject._layer_,))
        self.setText(x, y, text, font, size, bold, italic, color)
        canvas.tag_raise(TextObject._layer_)

    def setText(
        self,
        x: int = None,
        y: int = None,
        text: str = None,
        font: str = None,
        size: int = None,
        bold: bool = None,
        italic: bool = None,
        color: str = None,
    ):
        &#34;&#34;&#34;
        Modifica el texto desplegado y sus atributos. Si no se especifican atributos se convservan los existentes

        Args:
            x (int, optional): Coordenada x del texto.
            y (int, optional): Coordenada y del texto
            text (str, optional): Texto para este objeto
            font (str, optional): Font a utilizar para el texto
            size (int, optional): Tamano a utilizar para el texto
            bold (bool, optional): Especifica que el texto estara en bold
            italic (bool, optional): Especifica que el texto estara en italic
            color (str, optional): Color a utilizar para el texto
        &#34;&#34;&#34;
        canvas = self.gw._getCanvas()

        # la posicion del texto
        _x, _y = canvas.coords(self.text)
        if x is None:
            x = _x
        if y is None:
            y = _y
        x, y = int(x), int(y)
        dx = x - _x
        dy = y - _y
        canvas.move(self.text, dx, dy)

        # los atributos
        kwargs = {}
        if not text is None:
            kwargs[&#34;text&#34;] = text
        f = []
        if not font is None:
            f.append(font)
        if not size is None:
            f.append(size)
        t = &#34;&#34;
        if bold:
            t = t + &#34; bold &#34;
        if italic:
            t = t + &#34; italic &#34;
        if t:
            f.append(t)
        if f:
            kwargs[&#34;font&#34;] = tuple(f)
        if not color is None:
            kwargs[&#34;fill&#34;] = color
        canvas.itemconfig(self.text, kwargs)

    def destroy(self):
        &#34;&#34;&#34;
        Elimina este texto del mundo del juego
        &#34;&#34;&#34;
        self.gw._getCanvas().delete(self.text)
        self.text = None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MiniGameEngine.TextObject.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Elimina este texto del mundo del juego</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Elimina este texto del mundo del juego
    &#34;&#34;&#34;
    self.gw._getCanvas().delete(self.text)
    self.text = None</code></pre>
</details>
</dd>
<dt id="MiniGameEngine.TextObject.setText"><code class="name flex">
<span>def <span class="ident">setText</span></span>(<span>self, x: int = None, y: int = None, text: str = None, font: str = None, size: int = None, bold: bool = None, italic: bool = None, color: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifica el texto desplegado y sus atributos. Si no se especifican atributos se convservan los existentes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Coordenada x del texto.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Coordenada y del texto</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Texto para este objeto</dd>
<dt><strong><code>font</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Font a utilizar para el texto</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Tamano a utilizar para el texto</dd>
<dt><strong><code>bold</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Especifica que el texto estara en bold</dd>
<dt><strong><code>italic</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Especifica que el texto estara en italic</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color a utilizar para el texto</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setText(
    self,
    x: int = None,
    y: int = None,
    text: str = None,
    font: str = None,
    size: int = None,
    bold: bool = None,
    italic: bool = None,
    color: str = None,
):
    &#34;&#34;&#34;
    Modifica el texto desplegado y sus atributos. Si no se especifican atributos se convservan los existentes

    Args:
        x (int, optional): Coordenada x del texto.
        y (int, optional): Coordenada y del texto
        text (str, optional): Texto para este objeto
        font (str, optional): Font a utilizar para el texto
        size (int, optional): Tamano a utilizar para el texto
        bold (bool, optional): Especifica que el texto estara en bold
        italic (bool, optional): Especifica que el texto estara en italic
        color (str, optional): Color a utilizar para el texto
    &#34;&#34;&#34;
    canvas = self.gw._getCanvas()

    # la posicion del texto
    _x, _y = canvas.coords(self.text)
    if x is None:
        x = _x
    if y is None:
        y = _y
    x, y = int(x), int(y)
    dx = x - _x
    dy = y - _y
    canvas.move(self.text, dx, dy)

    # los atributos
    kwargs = {}
    if not text is None:
        kwargs[&#34;text&#34;] = text
    f = []
    if not font is None:
        f.append(font)
    if not size is None:
        f.append(size)
    t = &#34;&#34;
    if bold:
        t = t + &#34; bold &#34;
    if italic:
        t = t + &#34; italic &#34;
    if t:
        f.append(t)
    if f:
        kwargs[&#34;font&#34;] = tuple(f)
    if not color is None:
        kwargs[&#34;fill&#34;] = color
    canvas.itemconfig(self.text, kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MiniGameEngine.GameObject" href="#MiniGameEngine.GameObject">GameObject</a></code></h4>
<ul class="two-column">
<li><code><a title="MiniGameEngine.GameObject.collidesWith" href="#MiniGameEngine.GameObject.collidesWith">collidesWith</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.destroy" href="#MiniGameEngine.GameObject.destroy">destroy</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getHeight" href="#MiniGameEngine.GameObject.getHeight">getHeight</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getTipo" href="#MiniGameEngine.GameObject.getTipo">getTipo</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getWidth" href="#MiniGameEngine.GameObject.getWidth">getWidth</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getWorldHeight" href="#MiniGameEngine.GameObject.getWorldHeight">getWorldHeight</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getWorldWidth" href="#MiniGameEngine.GameObject.getWorldWidth">getWorldWidth</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getX" href="#MiniGameEngine.GameObject.getX">getX</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.getY" href="#MiniGameEngine.GameObject.getY">getY</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.isPressed" href="#MiniGameEngine.GameObject.isPressed">isPressed</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.loadImage" href="#MiniGameEngine.GameObject.loadImage">loadImage</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.loadImages" href="#MiniGameEngine.GameObject.loadImages">loadImages</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.onCollision" href="#MiniGameEngine.GameObject.onCollision">onCollision</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.onUpdate" href="#MiniGameEngine.GameObject.onUpdate">onUpdate</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.setBgPic" href="#MiniGameEngine.GameObject.setBgPic">setBgPic</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.setCollisions" href="#MiniGameEngine.GameObject.setCollisions">setCollisions</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.setPosition" href="#MiniGameEngine.GameObject.setPosition">setPosition</a></code></li>
<li><code><a title="MiniGameEngine.GameObject.setShape" href="#MiniGameEngine.GameObject.setShape">setShape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MiniGameEngine.GameWorld" href="#MiniGameEngine.GameWorld">GameWorld</a></code></h4>
<ul class="two-column">
<li><code><a title="MiniGameEngine.GameWorld.collide" href="#MiniGameEngine.GameWorld.collide">collide</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.exitGame" href="#MiniGameEngine.GameWorld.exitGame">exitGame</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.gameLoop" href="#MiniGameEngine.GameWorld.gameLoop">gameLoop</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.getWorldHeight" href="#MiniGameEngine.GameWorld.getWorldHeight">getWorldHeight</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.getWorldWidth" href="#MiniGameEngine.GameWorld.getWorldWidth">getWorldWidth</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.isPressed" href="#MiniGameEngine.GameWorld.isPressed">isPressed</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.loadImage" href="#MiniGameEngine.GameWorld.loadImage">loadImage</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.loadImages" href="#MiniGameEngine.GameWorld.loadImages">loadImages</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.onUpdate" href="#MiniGameEngine.GameWorld.onUpdate">onUpdate</a></code></li>
<li><code><a title="MiniGameEngine.GameWorld.setBgPic" href="#MiniGameEngine.GameWorld.setBgPic">setBgPic</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MiniGameEngine.TextObject" href="#MiniGameEngine.TextObject">TextObject</a></code></h4>
<ul class="">
<li><code><a title="MiniGameEngine.TextObject.destroy" href="#MiniGameEngine.TextObject.destroy">destroy</a></code></li>
<li><code><a title="MiniGameEngine.TextObject.setText" href="#MiniGameEngine.TextObject.setText">setText</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>